#coding=utf-8

'''
   文件读写
   Python内置的文件读写函数,用法和C是兼容的

   我们必须先了解: 在磁盘上读写文件的功能都是由操作系统提供的,现代操作系统不允许普通的程序直接操作磁盘,
   所以读写文件就是请求操作系统打开一个文件对象(通常称为 文件描述符 ),然后通过操作系统操作的接口,从这个
   文件对象中读取数据(读文件),或者把数据写入这个文件对象(写文件).
'''

__author__ = "i3342th"

#---------------------------读文件----------------------------------

f = open('../R/1.txt','r') # r表示读, 如果打开成功,接着就可以用read()来读取文件全部内容了,读到内存
str = f.read()
f.close()# 必须关闭,因为文件对象会占用操作系统的资源,并且操作系统同一时间能打开的文件数量是有限的
print str


# 由于文件读写都有可能产生IoError, 一旦出错,后面的 f.close()就不会调用, 所以为了保证无论是否出错都能
# 正确关闭文件,我们可以用try...catch

try:
    f = open('../R/1.txt','r')
    print f.read()
finally:
    if f:
        f.close()

# 但是每次这样写太繁琐,所以Pyrthon引入了with语句来自动帮我们调用close()方法 :
# 这样更简洁
with open('../R/1.txt','r') as f:
    print f.read()


# 调用read()方法, 会一次性读取文件全部内容,如果文件有10G,内在就爆了,所以保险起见,可以反复调用read(size)
# 每冷饮最多读取size个字节的内容, 另外调用 readline()可以每次读取一行的内容,调用readlines()一次读取所有
# 内容,并且按行返回list

with open('../R/1.txt','r') as f:
    for line in f.readlines():
        print (line.strip()) #把末尾的'\n'删掉



#---------------------------file-like  Object ---------------------------------------
#像 open()函数返回的这种有个read()方法的对象, 在Python中统称为  file-like object ,除了file外,
#还可以是内存的字节流, 网络流, 自定义流等. file-like object 不要求从特定类继承, 只要写个 read()方法就行
#StringIO就是在内在中创建的file-like object,常用作临时缓冲

#--------------------------二进制文件--------------------------------------
# 前面讲的都是读取文本文件,并且是ASCII编码的文本文件,
# 要读取二进制文件,如果图片/视频等等, 用'rb'模式打开文件即可
with open('../R/1.jpg','rb') as f:
#    print f.read()
    pass

#--------------------------字符编码-----------------------------------------------
# 要读取非ASCII编码的文本文件, 就必须以二进制模式打开,再解码,比如GBK编码的文件:
with open('../R/GB2312.txt','r') as f:
    u = f.read()
    print u
    u = u.decode('GB2312')
    print u

# 如果每次都这么手动转换编码嫌麻烦, Python还提供了一个codecs模块帮助我们在读文件时自动转换编码
# 直接读出 unicode:
import codecs
with codecs.open('../R/GB2312.txt','r','GB2312') as f:
    print f.read()


# ----------------------------写文件----------------------------------------------
# 写文件和读文件是一样的,唯一区别是调用open()函数时
# 传入标识符 'w' 或者 'wb'　表示写文件文件或二进制文件

with open('../R/1.txt','w') as f:
    f.write('Hello')
    f.write('World')
    f.write('HaHa')

# 务必调用close()方法来关闭文件, 我们写文件时,操作系统往往不会立刻把数据写入磁盘, 而是放到内存缓存起来
# 空闲的时候再慢慢写入,只有调用 close() 方法时,操作系统才保证把没有写入的数据全部写入磁盘,忘记调用 close()
# 的后果是数据可能只写了一部分到磁盘,剩下的丢失了, 所以还是用 with 语句保险

# 要写入特定编码的文本文件, 效仿读取











